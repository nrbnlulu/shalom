{% include "macros" %}

{% set op_variables = context.operation.variables %}
{% set op_variables_exist = context.operation.variables | length > 0 %}
{% set typedefs = context.operation.typedefs %}


// ignore_for_file: constant_identifier_names, non_constant_identifier_names, unused_import, camel_case_types, unnecessary_this, unnecessary_non_null_assertion, depend_on_referenced_packages, empty_statements, annotate_overrides, no_leading_underscores_for_local_identifiers, unnecessary_cast, camel_case_extensions

import "{{ context.schema_import_path }}";
{{ custom_scalar_imports_macro(context.custom_scalar_imports) }}
{% set OP_TYPE = context.operation.op_ty.name|upper %}

import 'package:shalom_core/shalom_core.dart';
import 'package:collection/collection.dart';

// Fragment imports
{% for import_path in generate_fragment_imports(context.operation.file_path) -%}
import '{{ import_path }}';
{% endfor -%}


{% set operation_name = context.operation.operation_name %}

{% include "selection_macros" %}

// ------------ OBJECT DEFINITIONS -------------
{% set response_class_name = operation_name ~ "Response" %}
class {{ response_class_name }} {{ implements_used_fragments(context.operation.root_type.used_fragments) }}  {
    {{ selection_object_impl(response_class_name, context.operation.root_type, is_root_selection=true, full_name=context.operation.root_type.path_name) }}
}

{# Build a set of all union and interface member names to skip #}
{% set multi_type_member_names = [] %}
{% for union_full_name, union_selection in typedefs.unions | items %}
    {% for type_condition in union_selection.inline_fragments | keys %}
        {% set _ = multi_type_member_names.append(union_full_name ~ "_" ~ type_condition) %}
    {% endfor %}
{% endfor %}
{% for interface_full_name, interface_selection in typedefs.interfaces | items %}
    {% for type_condition in interface_selection.inline_fragments | keys %}
        {% set _ = multi_type_member_names.append(interface_full_name ~ "_" ~ type_condition) %}
    {% endfor %}
{% endfor %}

{% for full_name, selection in typedefs.objects | items %}
    {# Skip union/interface member objects - they'll be generated in UNION/INTERFACE DEFINITIONS #}
    {% if full_name not in multi_type_member_names %}
        {{ selection_object_definition(full_name, selection) }}
    {% endif %}
{% endfor %}

{# Generate object classes for list items #}
{% for selection_name, list_selection in typedefs.lists | items %}
    {% if list_selection.of_kind.kind == "Object" %}
        {# Generate the object class for list items #}
        {{ selection_object_definition(selection_name, list_selection.of_kind) }}
    {% endif %}
{% endfor %}

// ------------ END OBJECT DEFINITIONS -------------

// ------------ UNION DEFINITIONS -------------

{# First generate union member object classes #}
{% set union_types = typedefs.unions %}
{% for union_full_name, union_selection in union_types | items %}
    {% for type_condition, obj_selection in union_selection.inline_fragments | items %}
        {# Generate union member object using the unified macro with shared selections #}
        {% set member_full_name = union_full_name ~ "_" ~ type_condition %}
        {# Look up the full Selection from context which includes arguments #}
        {% set member_selection = typedefs.objects[member_full_name] %}
        {# We need to create a wrapper that passes shared_selections to selection_object_impl #}
        class {{ member_full_name }} extends {{ union_full_name }}{{ implements_used_fragments(obj_selection.used_fragments) }}  {
            {{ selection_object_impl(member_full_name, member_selection, false, obj_selection.path_name, is_multi_type_member=true, shared_selections=union_selection.shared_selections) }}
        }
    {% endfor %}

    {# Generate fallback class if needed #}
    {% if union_selection.has_fallback %}
        {% set fallback_full_name = union_full_name ~ "_Fallback" %}
        class {{ fallback_full_name }} extends {{ union_full_name }} {
            {{ selection_interface_fallback_impl(fallback_full_name, union_selection) }}
        }
    {% endif %}
{% endfor %}

{# Then generate union sealed classes #}
{% for full_name, selection in typedefs.unions | items %}
    {{ multi_type_selection_definition(full_name, selection) }}
{% endfor %}

// ------------ END UNION DEFINITIONS -------------

// ------------ INTERFACE DEFINITIONS -------------

{# First generate interface member object classes #}
{% for interface_full_name, interface_selection in typedefs.interfaces | items %}
    {% for type_condition, obj_selection in interface_selection.inline_fragments | items %}
        {# Generate interface member object using the unified macro with shared selections #}
        {% set member_full_name = interface_full_name ~ "_" ~ type_condition %}
        {# Look up the full Selection from context which includes arguments #}
        {% set member_selection = typedefs.objects[member_full_name] %}
        class {{ member_full_name }} extends {{ interface_full_name }}{{ implements_used_fragments(obj_selection.used_fragments) }}  {
            {{ selection_object_impl(member_full_name, member_selection, false, obj_selection.path_name, is_multi_type_member=true, shared_selections=interface_selection.shared_selections) }}
        }
    {% endfor %}

    {# Generate fallback class if needed #}
    {% if interface_selection.has_fallback %}
        {% set fallback_full_name = interface_full_name ~ "_Fallback" %}
        class {{ fallback_full_name }} extends {{ interface_full_name }} {
            {{ selection_interface_fallback_impl(fallback_full_name, interface_selection) }}
        }
    {% endif %}
{% endfor %}

{# Then generate interface abstract classes #}
{% for full_name, selection in typedefs.interfaces | items %}
    {{ multi_type_selection_definition(full_name, selection) }}
{% endfor %}

// ------------ END INTERFACE DEFINITIONS -------------

{{ generate_multi_type_list_extensions(multi_type_list_selections) }}

class Request{{ operation_name }} extends Requestable<{{operation_name}}Response>{
    {% if op_variables_exist %}
    final {{ operation_name }}Variables variables;
    {% endif %}

    Request{{ operation_name }}(
        {% if op_variables_exist %}
        {
            required this.variables,
        }
        {% endif %}
    );
    @override
    RequestMeta<{{operation_name}}Response> getRequestMeta(){
        JsonObject variablesJson = {% if op_variables_exist %} variables.toJson() {% else %} {}  {% endif %};
        final request = Request(
            query: r"""
            {{context.resolved_query}}
            """,
            variables: variablesJson,
            opType: OperationType.{{ context.operation.op_ty.name }},
            opName: '{{ operation_name }}',
        );
        return RequestMeta(
            request: request,
            loadFn: ({required JsonObject data, required ShalomCtx ctx}){
                final (deserialized, updatedCtx) = {{operation_name}}Response.fromResponseImpl(data, ctx{% if op_variables_exist %}, variables{% endif %});
                return (deserialized, updatedCtx.dependantRecords);
            },
            fromCacheFn: (ShalomCtx ctx){
                final updateCtx = CacheUpdateContext(shalomContext: ctx);
                final deserialized = {{operation_name}}Response.fromCache(ctx{% if op_variables_exist %}, variables{% endif %});
                return (deserialized, updateCtx.dependantRecords);
            }
        );
    }
}

{% if op_variables_exist %}
class {{ operation_name }}Variables {
    {% set typename = operation_name ~ 'Variables' %}
    {% set fields_requiring_initializer_list = get_fields_requiring_initializer_list(op_variables) %}
    {% for name, variable in op_variables | items %}
        final {{ type_name_for_input_field(variable) }} {{ name }};
    {% endfor %}

    {{ typename }}(
        {
        {% for name, field in op_variables | items -%}
            {% if name not in fields_requiring_initializer_list -%}
                {{input_field_constructor_initialization(name, field, required_initializer=false)}},
            {% endif -%}
        {% endfor -%}
        {% for name, field in fields_requiring_initializer_list | items -%}
            {{input_field_constructor_initialization(name, field, required_initializer=true)}},
        {% endfor -%}
        }
    ){{ field_initialization_initializers(op_variables) }};

    JsonObject toJson() {
        JsonObject data = {};
        {{ toJson_macro(op_variables) }}
        return data;
    }

    {{ updateWith_macro(op_variables, typename) }}

}
{% endif %}
